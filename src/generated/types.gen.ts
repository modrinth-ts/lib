// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.modrinth.com/v2' | 'https://staging-api.modrinth.com/v2' | 'https://api.modrinth.com' | 'https://staging-api.modrinth.com' | (string & {});
};

export type BaseVersion = {
    /**
     * The name of this version
     */
    name?: string;
    /**
     * The version number. Ideally will follow semantic versioning
     */
    version_number?: string;
    /**
     * The changelog for this version
     */
    changelog?: string | null;
    /**
     * A list of specific versions of projects that this version depends on
     */
    dependencies?: Array<VersionDependency>;
    /**
     * A list of versions of Minecraft that this version supports
     */
    game_versions?: Array<string>;
    /**
     * The release channel for this version
     */
    version_type?: 'release' | 'beta' | 'alpha';
    /**
     * The mod loaders that this version supports. In case of resource packs, use "minecraft"
     */
    loaders?: Array<string>;
    /**
     * Whether the version is featured or not
     */
    featured?: boolean;
    status?: 'listed' | 'archived' | 'draft' | 'unlisted' | 'scheduled' | 'unknown';
    requested_status?: 'listed' | 'archived' | 'draft' | 'unlisted';
};

export type VersionDependency = {
    /**
     * The ID of the version that this version depends on
     */
    version_id?: string | null;
    /**
     * The ID of the project that this version depends on
     */
    project_id?: string | null;
    /**
     * The file name of the dependency, mostly used for showing external dependencies on modpacks
     */
    file_name?: string | null;
    /**
     * The type of dependency that this version has
     */
    dependency_type: 'required' | 'optional' | 'incompatible' | 'embedded';
};

export type EditableVersion = BaseVersion & {
    /**
     * The hash format and the hash of the new primary file
     */
    primary_file?: Array<string>;
    /**
     * A list of file_types to edit
     */
    file_types?: Array<EditableFileType>;
};

export type EditableFileType = {
    /**
     * The hash algorithm of the hash specified in the hash field
     */
    algorithm: string;
    /**
     * The hash of the file you're editing
     */
    hash: string;
    /**
     * The hash algorithm of the file you're editing
     */
    file_type: 'required-resource-pack' | 'optional-resource-pack';
};

export type CreatableVersion = BaseVersion & {
    /**
     * The ID of the project this version is for
     */
    project_id: string;
    /**
     * An array of the multipart field names of each file that goes with this version
     */
    file_parts: Array<string>;
    /**
     * The multipart field name of the primary file
     */
    primary_file?: string;
};

export type CreateVersionBody = {
    data: CreatableVersion;
};

export type Version = BaseVersion & {
    /**
     * The ID of the version, encoded as a base62 string
     */
    id: string;
    /**
     * The ID of the project this version is for
     */
    project_id: string;
    /**
     * The ID of the author who published this version
     */
    author_id: string;
    date_published: string;
    /**
     * The number of times this version has been downloaded
     */
    downloads: number;
    /**
     * A link to the changelog for this version. Always null, only kept for legacy compatibility.
     *
     * @deprecated
     */
    changelog_url?: string | null;
    /**
     * A list of files available for download for this version
     */
    files: Array<VersionFile>;
};

export type VersionFile = {
    hashes: VersionFileHashes;
    /**
     * A direct link to the file
     */
    url: string;
    /**
     * The name of the file
     */
    filename: string;
    /**
     * Whether this file is the primary one for its version. Only a maximum of one file per version will have this set to true. If there are not any primary files, it can be inferred that the first file is the primary one.
     */
    primary: boolean;
    /**
     * The size of the file in bytes
     */
    size: number;
    /**
     * The type of the additional file, used mainly for adding resource packs to datapacks
     */
    file_type?: 'required-resource-pack' | 'optional-resource-pack';
};

/**
 * A map of hashes of the file. The key is the hashing algorithm and the value is the string version of the hash.
 */
export type VersionFileHashes = {
    sha512?: string;
    sha1?: string;
};

export type GetLatestVersionFromHashBody = {
    loaders: Array<string>;
    game_versions: Array<string>;
};

/**
 * A map from hashes to versions
 */
export type HashVersionMap = {
    [key: string]: Version;
};

/**
 * A list of hashes and the algorithm used to create them
 */
export type HashList = {
    hashes: Array<string>;
    algorithm: 'sha1' | 'sha512';
};

export type GetLatestVersionsFromHashesBody = HashList & {
    loaders: Array<string>;
    game_versions: Array<string>;
};

export type BaseProject = {
    /**
     * The slug of a project, used for vanity URLs. Regex: ```^[\w!@$()`.+,"\-']{3,64}$```
     */
    slug?: string;
    /**
     * The title or name of the project
     */
    title?: string;
    /**
     * A short description of the project
     */
    description?: string;
    /**
     * A list of the categories that the project has
     */
    categories?: Array<string>;
    /**
     * The client side support of the project
     */
    client_side?: 'required' | 'optional' | 'unsupported' | 'unknown';
    /**
     * The server side support of the project
     */
    server_side?: 'required' | 'optional' | 'unsupported' | 'unknown';
};

export type ServerRenderedProject = BaseProject & {
    /**
     * The project type of the project
     */
    project_type: 'mod' | 'modpack' | 'resourcepack' | 'shader';
    /**
     * The total number of downloads of the project
     */
    downloads: number;
    /**
     * The URL of the project's icon
     */
    icon_url?: string | null;
    /**
     * The RGB color of the project, automatically generated from the project icon
     */
    color?: number | null;
    /**
     * The ID of the moderation thread associated with this project
     */
    thread_id?: string;
    monetization_status?: 'monetized' | 'demonetized' | 'force-demonetized';
};

export type ProjectResult = ServerRenderedProject & {
    /**
     * The ID of the project
     */
    project_id: string;
    /**
     * The username of the project's author
     */
    author: string;
    /**
     * A list of the categories that the project has which are not secondary
     */
    display_categories?: Array<string>;
    /**
     * A list of the minecraft versions supported by the project
     */
    versions: Array<string>;
    /**
     * The total number of users following the project
     */
    follows: number;
    /**
     * The date the project was added to search
     */
    date_created: string;
    /**
     * The date the project was last modified
     */
    date_modified: string;
    /**
     * The latest version of minecraft that this project supports
     */
    latest_version?: string;
    /**
     * The SPDX license ID of a project
     */
    license: string;
    /**
     * All gallery images attached to the project
     */
    gallery?: Array<string>;
    /**
     * The featured gallery image of the project
     */
    featured_gallery?: string | null;
};

export type NonSearchProject = BaseProject & {
    /**
     * A long form description of the project
     */
    body?: string;
    /**
     * The status of the project
     */
    status?: 'approved' | 'archived' | 'rejected' | 'draft' | 'unlisted' | 'processing' | 'withheld' | 'scheduled' | 'private' | 'unknown';
    /**
     * The requested status when submitting for review or scheduling the project for release
     */
    requested_status?: 'approved' | 'archived' | 'unlisted' | 'private' | 'draft';
    /**
     * A list of categories which are searchable but non-primary
     */
    additional_categories?: Array<string>;
    /**
     * An optional link to where to submit bugs or issues with the project
     */
    issues_url?: string | null;
    /**
     * An optional link to the source code of the project
     */
    source_url?: string | null;
    /**
     * An optional link to the project's wiki page or other relevant information
     */
    wiki_url?: string | null;
    /**
     * An optional invite link to the project's discord
     */
    discord_url?: string | null;
    /**
     * A list of donation links for the project
     */
    donation_urls?: Array<ProjectDonationUrl>;
};

export type ProjectDonationUrl = {
    /**
     * The ID of the donation platform
     */
    id?: string;
    /**
     * The donation platform this link is to
     */
    platform?: string;
    /**
     * The URL of the donation platform and user
     */
    url?: string;
};

export type ModifiableProject = NonSearchProject & {
    /**
     * The SPDX license ID of a project
     */
    license_id?: string;
    /**
     * The URL to this license
     */
    license_url?: string | null;
};

export type EditableProject = ModifiableProject & {
    /**
     * The title of the moderators' message for the project
     */
    moderation_message?: string | null;
    /**
     * The body of the moderators' message for the project
     */
    moderation_message_body?: string | null;
};

export type CreatableProject = ModifiableProject & {
    project_type: 'mod' | 'modpack';
    /**
     * A list of initial versions to upload with the created project. Deprecated - please upload version files after initial upload.
     *
     * @deprecated
     */
    initial_versions?: Array<EditableVersion>;
    /**
     * Whether the project should be saved as a draft instead of being sent to moderation for review. Deprecated - please always mark this as true.
     *
     * @deprecated
     */
    is_draft?: boolean;
    /**
     * Gallery images to be uploaded with the created project. Deprecated - please upload gallery images after initial upload.
     *
     * @deprecated
     */
    gallery_items?: Array<CreatableProjectGalleryItem>;
};

export type CreatableProjectGalleryItem = {
    /**
     * The name of the multipart item where the gallery media is located
     */
    item?: string;
    /**
     * Whether the image is featured in the gallery
     */
    featured?: boolean;
    /**
     * The title of the gallery image
     */
    title?: string | null;
    /**
     * The description of the gallery image
     */
    description?: string | null;
    /**
     * The order of the gallery image. Gallery images are sorted by this field and then alphabetically by title.
     */
    ordering?: number;
} | null;

export type Project = NonSearchProject & ServerRenderedProject & {
    /**
     * The ID of the project, encoded as a base62 string
     */
    id: string;
    /**
     * The ID of the team that has ownership of this project
     */
    team: string;
    /**
     * The link to the long description of the project. Always null, only kept for legacy compatibility.
     *
     * @deprecated
     */
    body_url?: string | null;
    moderator_message?: ModeratorMessage;
    /**
     * The date the project was published
     */
    published: string;
    /**
     * The date the project was last updated
     */
    updated: string;
    /**
     * The date the project's status was set to an approved status
     */
    approved?: string | null;
    /**
     * The date the project's status was submitted to moderators for review
     */
    queued?: string | null;
    /**
     * The total number of users following the project
     */
    followers: number;
    license?: ProjectLicense;
    /**
     * A list of the version IDs of the project (will never be empty unless `draft` status)
     */
    versions?: Array<string>;
    /**
     * A list of all of the game versions supported by the project
     */
    game_versions?: Array<string>;
    /**
     * A list of all of the loaders supported by the project
     */
    loaders?: Array<string>;
    /**
     * A list of images that have been uploaded to the project's gallery
     */
    gallery?: Array<GalleryImage>;
};

/**
 * A message that a moderator sent regarding the project
 *
 * @deprecated
 */
export type ModeratorMessage = {
    /**
     * The message that a moderator has left for the project
     */
    message?: string;
    /**
     * The longer body of the message that a moderator has left for the project
     */
    body?: string | null;
} | null;

/**
 * The license of the project
 */
export type ProjectLicense = {
    /**
     * The SPDX license ID of a project
     */
    id?: string;
    /**
     * The long name of a license
     */
    name?: string;
    /**
     * The URL to this license
     */
    url?: string | null;
};

export type GalleryImage = {
    /**
     * The URL of the gallery image
     */
    url: string;
    /**
     * Whether the image is featured in the gallery
     */
    featured: boolean;
    /**
     * The title of the gallery image
     */
    title?: string | null;
    /**
     * The description of the gallery image
     */
    description?: string | null;
    /**
     * The date and time the gallery image was created
     */
    created: string;
    /**
     * The order of the gallery image. Gallery images are sorted by this field and then alphabetically by title.
     */
    ordering?: number;
} | null;

export type ProjectDependencyList = {
    /**
     * Projects that the project depends upon
     */
    projects?: Array<Project>;
    /**
     * Versions that the project depends upon
     */
    versions?: Array<Version>;
};

export type PatchProjectsBody = {
    /**
     * Set all of the categories to the categories specified here
     */
    categories?: Array<string>;
    /**
     * Add all of the categories specified here
     */
    add_categories?: Array<string>;
    /**
     * Remove all of the categories specified here
     */
    remove_categories?: Array<string>;
    /**
     * Set all of the additional categories to the categories specified here
     */
    additional_categories?: Array<string>;
    /**
     * Add all of the additional categories specified here
     */
    add_additional_categories?: Array<string>;
    /**
     * Remove all of the additional categories specified here
     */
    remove_additional_categories?: Array<string>;
    /**
     * Set all of the donation links to the donation links specified here
     */
    donation_urls?: Array<ProjectDonationUrl>;
    /**
     * Add all of the donation links specified here
     */
    add_donation_urls?: Array<ProjectDonationUrl>;
    /**
     * Remove all of the donation links specified here
     */
    remove_donation_urls?: Array<ProjectDonationUrl>;
    /**
     * An optional link to where to submit bugs or issues with the projects
     */
    issues_url?: string | null;
    /**
     * An optional link to the source code of the projects
     */
    source_url?: string | null;
    /**
     * An optional link to the projects' wiki page or other relevant information
     */
    wiki_url?: string | null;
    /**
     * An optional invite link to the projects' discord
     */
    discord_url?: string | null;
};

export type CreateProjectBody = {
    data: CreatableProject;
    /**
     * Project icon file
     */
    icon?: '*.png' | '*.jpg' | '*.jpeg' | '*.bmp' | '*.gif' | '*.webp' | '*.svg' | '*.svgz' | '*.rgb';
};

export type ProjectIdentifier = {
    id?: string;
};

export type Schedule = {
    time: string;
    /**
     * The requested status when scheduling the project for release
     */
    requested_status: 'approved' | 'archived' | 'unlisted' | 'private' | 'draft';
};

export type SearchResults = {
    /**
     * The list of results
     */
    hits: Array<ProjectResult>;
    /**
     * The number of results that were skipped by the query
     */
    offset: number;
    /**
     * The number of results that were returned by the query
     */
    limit: number;
    /**
     * The total number of results that match the query
     */
    total_hits: number;
};

export type UserIdentifier = {
    user_id: string;
};

export type EditableUser = {
    /**
     * The user's username
     */
    username: string;
    /**
     * The user's display name
     */
    name?: string | null;
    /**
     * The user's email (only displayed if requesting your own account). Requires `USER_READ_EMAIL` PAT scope.
     */
    email?: string | null;
    /**
     * A description of the user
     */
    bio?: string;
    payout_data?: UserPayoutData;
};

/**
 * Various data relating to the user's payouts status (you can only see your own)
 */
export type UserPayoutData = {
    /**
     * The payout balance available for the user to withdraw (note, you cannot modify this in a PATCH request)
     */
    balance?: number;
    /**
     * The wallet that the user has selected
     */
    payout_wallet?: 'paypal' | 'venmo';
    /**
     * The type of the user's wallet
     */
    payout_wallet_type?: 'email' | 'phone' | 'user_handle';
    /**
     * The user's payout address
     */
    payout_address?: string;
} | null;

export type User = EditableUser & {
    /**
     * The user's ID
     */
    id: string;
    /**
     * The user's avatar url
     */
    avatar_url: string;
    /**
     * The time at which the user was created
     */
    created: string;
    /**
     * The user's role
     */
    role: 'admin' | 'moderator' | 'developer';
    /**
     * Any badges applicable to this user. These are currently unused and undisplayed, and as such are subject to change
     *
     * In order from first to seventh bit, the current bits are:
     * - (unused)
     * - EARLY_MODPACK_ADOPTER
     * - EARLY_RESPACK_ADOPTER
     * - EARLY_PLUGIN_ADOPTER
     * - ALPHA_TESTER
     * - CONTRIBUTOR
     * - TRANSLATOR
     *
     */
    badges?: number;
    /**
     * A list of authentication providers you have signed up for (only displayed if requesting your own account)
     */
    auth_providers?: Array<string> | null;
    /**
     * Whether your email is verified (only displayed if requesting your own account)
     */
    email_verified?: boolean | null;
    /**
     * Whether you have a password associated with your account (only displayed if requesting your own account)
     */
    has_password?: boolean | null;
    /**
     * Whether you have TOTP two-factor authentication connected to your account (only displayed if requesting your own account)
     */
    has_totp?: boolean | null;
    /**
     * Deprecated - this is no longer public for security reasons and is always null
     *
     * @deprecated
     */
    github_id?: number | null;
};

export type UserPayoutHistory = {
    /**
     * The all-time balance accrued by this user in USD
     */
    all_time?: string;
    /**
     * The amount in USD made by the user in the previous 30 days
     */
    last_month?: string;
    /**
     * A history of all of the user's past transactions
     */
    payouts?: Array<UserPayoutHistoryEntry>;
};

export type UserPayoutHistoryEntry = {
    /**
     * The date of this transaction
     */
    created?: string;
    /**
     * The amount of this transaction in USD
     */
    amount?: number;
    /**
     * The status of this transaction
     */
    status?: string;
};

export type Notification = {
    /**
     * The id of the notification
     */
    id: string;
    /**
     * The id of the user who received the notification
     */
    user_id: string;
    /**
     * The type of notification
     */
    type?: 'project_update' | 'team_invite' | 'status_change' | 'moderator_message';
    /**
     * The title of the notification
     */
    title: string;
    /**
     * The body text of the notification
     */
    text: string;
    /**
     * A link to the related project or version
     */
    link: string;
    /**
     * Whether the notification has been read or not
     */
    read: boolean;
    /**
     * The time at which the notification was created
     */
    created: string;
    /**
     * A list of actions that can be performed
     */
    actions: Array<NotificationAction>;
};

/**
 * An action that can be performed on a notification
 */
export type NotificationAction = {
    /**
     * The friendly name for this action
     */
    title?: string;
    /**
     * The HTTP code and path to request in order to perform this action.
     */
    action_route?: Array<string>;
};

export type CreatableReport = {
    /**
     * The type of the report being sent
     */
    report_type: string;
    /**
     * The ID of the item (project, version, or user) being reported
     */
    item_id: string;
    /**
     * The type of the item being reported
     */
    item_type: 'project' | 'user' | 'version';
    /**
     * The extended explanation of the report
     */
    body: string;
};

export type Report = CreatableReport & {
    /**
     * The ID of the report
     */
    id?: string;
    /**
     * The ID of the user who reported the item
     */
    reporter: string;
    /**
     * The time at which the report was created
     */
    created: string;
    /**
     * Whether the report is resolved
     */
    closed: boolean;
    /**
     * The ID of the moderation thread associated with this report
     */
    thread_id: string;
};

export type Thread = {
    /**
     * The ID of the thread
     */
    id: string;
    type: 'project' | 'report' | 'direct_message';
    /**
     * The ID of the associated project if a project thread
     */
    project_id?: string | null;
    /**
     * The ID of the associated report if a report thread
     */
    report_id?: string | null;
    messages: Array<ThreadMessage>;
    members: Array<User>;
};

export type ThreadMessage = {
    /**
     * The ID of the message itself
     */
    id: string;
    /**
     * The ID of the author
     */
    author_id?: string | null;
    body: ThreadMessageBody;
    /**
     * The time at which the message was created
     */
    created: string;
};

/**
 * The contents of the message. **Fields will vary depending on message type.**
 */
export type ThreadMessageBody = {
    /**
     * The type of message
     */
    type: 'status_change' | 'text' | 'thread_closure' | 'deleted';
    /**
     * The actual message text. **Only present for `text` message type**
     */
    body?: string;
    /**
     * Whether the message is only visible to moderators. **Only present for `text` message type**
     */
    private?: boolean;
    /**
     * The ID of the message being replied to by this message. **Only present for `text` message type**
     */
    replying_to?: string | null;
    /**
     * The old status of the project. **Only present for `status_change` message type**
     */
    old_status?: 'approved' | 'archived' | 'rejected' | 'draft' | 'unlisted' | 'processing' | 'withheld' | 'scheduled' | 'private' | 'unknown';
    /**
     * The new status of the project. **Only present for `status_change` message type**
     */
    new_status?: 'approved' | 'archived' | 'rejected' | 'draft' | 'unlisted' | 'processing' | 'withheld' | 'scheduled' | 'private' | 'unknown';
};

export type TeamMember = {
    /**
     * The ID of the team this team member is a member of
     */
    team_id: string;
    user: User;
    /**
     * The user's role on the team
     */
    role: string;
    /**
     * The user's permissions in bitfield format (requires authorization to view)
     *
     * In order from first to tenth bit, the bits are:
     * - UPLOAD_VERSION
     * - DELETE_VERSION
     * - EDIT_DETAILS
     * - EDIT_BODY
     * - MANAGE_INVITES
     * - REMOVE_MEMBER
     * - EDIT_MEMBER
     * - DELETE_PROJECT
     * - VIEW_ANALYTICS
     * - VIEW_PAYOUTS
     *
     */
    permissions?: number;
    /**
     * Whether or not the user has accepted to be on the team (requires authorization to view)
     */
    accepted: boolean;
    /**
     * The split of payouts going to this user. The proportion of payouts they get is their split divided by the sum of the splits of all members.
     */
    payouts_split?: number;
    /**
     * The order of the team member.
     */
    ordering?: number;
};

export type CategoryTag = {
    /**
     * The SVG icon of a category
     */
    icon: string;
    /**
     * The name of the category
     */
    name: string;
    /**
     * The project type this category is applicable to
     */
    project_type: string;
    /**
     * The header under which the category should go
     */
    header: string;
};

export type LoaderTag = {
    /**
     * The SVG icon of a loader
     */
    icon: string;
    /**
     * The name of the loader
     */
    name: string;
    /**
     * The project types that this loader is applicable to
     */
    supported_project_types: Array<string>;
};

export type GameVersionTag = {
    /**
     * The name/number of the game version
     */
    version: string;
    /**
     * The type of the game version
     */
    version_type: 'release' | 'snapshot' | 'alpha' | 'beta';
    /**
     * The date of the game version release
     */
    date: string;
    /**
     * Whether or not this is a major version, used for Featured Versions
     */
    major: boolean;
};

export type DonationPlatformTag = {
    /**
     * The short identifier of the donation platform
     */
    short: string;
    /**
     * The full name of the donation platform
     */
    name: string;
};

export type ModifyTeamMemberBody = {
    role?: string;
    /**
     * The user's permissions in bitfield format
     *
     * In order from first to tenth bit, the bits are:
     * - UPLOAD_VERSION
     * - DELETE_VERSION
     * - EDIT_DETAILS
     * - EDIT_BODY
     * - MANAGE_INVITES
     * - REMOVE_MEMBER
     * - EDIT_MEMBER
     * - DELETE_PROJECT
     * - VIEW_ANALYTICS
     * - VIEW_PAYOUTS
     *
     */
    permissions?: number;
    /**
     * The split of payouts going to this user. The proportion of payouts they get is their split divided by the sum of the splits of all members.
     */
    payouts_split?: number;
    /**
     * The order of the team member.
     */
    ordering?: number;
};

/**
 * A short overview of a license
 */
export type LicenseTag = {
    /**
     * The short identifier of the license
     */
    short: string;
    /**
     * The full name of the license
     */
    name: string;
};

/**
 * A full license
 */
export type License = {
    title?: string;
    body?: string;
};

export type InvalidInputError = {
    /**
     * The name of the error
     */
    error: string;
    /**
     * The contents of the error
     */
    description: string;
};

export type AuthError = {
    /**
     * The name of the error
     */
    error: string;
    /**
     * The contents of the error
     */
    description: string;
};

export type Statistics = {
    /**
     * Number of projects on Modrinth
     */
    projects?: number;
    /**
     * Number of versions on Modrinth
     */
    versions?: number;
    /**
     * Number of version files on Modrinth
     */
    files?: number;
    /**
     * Number of authors (users with projects) on Modrinth
     */
    authors?: number;
};

/**
 * Mod version information that can be consumed by Forge's update checker
 */
export type ForgeUpdates = {
    /**
     * A link to the mod page
     */
    homepage?: string;
    promos?: ForgeUpdateCheckerPromos;
};

/**
 * A list of the recommended and latest versions for each Minecraft release
 */
export type ForgeUpdateCheckerPromos = {
    /**
     * The mod version that is recommended for `{version}`. Excludes versions with the `alpha` and `beta` version types.
     */
    '{version}-recommended'?: string;
    /**
     * The latest mod version for `{version}`. Shows versions with the `alpha` and `beta` version types.
     */
    '{version}-latest'?: string;
};

/**
 * The ID or slug of the project
 */
export type ProjectIdentifier2 = string;

/**
 * The IDs and/or slugs of the projects
 */
export type MultipleProjectIdentifier = string;

/**
 * The ID or username of the user
 */
export type UserIdentifier2 = string;

/**
 * The ID of the version
 */
export type VersionIdentifier = string;

/**
 * The ID of the team
 */
export type TeamIdentifier = string;

/**
 * The ID of the report
 */
export type ReportIdentifier = string;

/**
 * The ID of the thread
 */
export type ThreadIdentifier = string;

/**
 * The ID of the notification
 */
export type NotificationIdentifier = string;

/**
 * The algorithm of the hash
 */
export type AlgorithmIdentifier = 'sha1' | 'sha512';

/**
 * Whether to return multiple results when looking for this hash
 */
export type MultipleHashQueryIdentifier = boolean;

/**
 * The hash of the file, considering its byte content, and encoded in hexadecimal
 */
export type FileHashIdentifier = string;

export type Image = Blob | File;

export type SearchProjectsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The query to search for
         */
        query?: string;
        /**
         * Facets are an essential concept for understanding how to filter out results.
         *
         * These are the most commonly used facet types:
         * - `project_type`
         * - `categories` (loaders are lumped in with categories in search)
         * - `versions`
         * - `client_side`
         * - `server_side`
         * - `open_source`
         *
         * Several others are also available for use, though these should not be used outside very specific use cases.
         * - `title`
         * - `author`
         * - `follows`
         * - `project_id`
         * - `license`
         * - `downloads`
         * - `color`
         * - `created_timestamp` (uses Unix timestamp)
         * - `modified_timestamp` (uses Unix timestamp)
         * - `date_created` (uses ISO-8601 timestamp)
         * - `date_modified` (uses ISO-8601 timestamp)
         *
         * In order to then use these facets, you need a value to filter by, as well as an operation to perform on this value.
         * The most common operation is `:` (same as `=`), though you can also use `!=`, `>=`, `>`, `<=`, and `<`.
         * Join together the type, operation, and value, and you've got your string.
         * ```
         * {type} {operation} {value}
         * ```
         *
         * Examples:
         * ```
         * categories = adventure
         * versions != 1.20.1
         * downloads <= 100
         * ```
         *
         * You then join these strings together in arrays to signal `AND` and `OR` operators.
         *
         * ##### OR
         * All elements in a single array are considered to be joined by OR statements.
         * For example, the search `[["versions:1.16.5", "versions:1.17.1"]]` translates to `Projects that support 1.16.5 OR 1.17.1`.
         *
         * ##### AND
         * Separate arrays are considered to be joined by AND statements.
         * For example, the search `[["versions:1.16.5"], ["project_type:modpack"]]` translates to `Projects that support 1.16.5 AND are modpacks`.
         *
         */
        facets?: string;
        /**
         * The sorting method used for sorting search results
         */
        index?: 'relevance' | 'downloads' | 'follows' | 'newest' | 'updated';
        /**
         * The offset into the search. Skips this number of results
         */
        offset?: number;
        /**
         * The number of results returned by the search
         */
        limit?: number;
    };
    url: '/search';
};

export type SearchProjectsErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
};

export type SearchProjectsError = SearchProjectsErrors[keyof SearchProjectsErrors];

export type SearchProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    200: SearchResults;
};

export type SearchProjectsResponse = SearchProjectsResponses[keyof SearchProjectsResponses];

export type DeleteProjectData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}';
};

export type DeleteProjectErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type DeleteProjectError = DeleteProjectErrors[keyof DeleteProjectErrors];

export type DeleteProjectResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteProjectResponse = DeleteProjectResponses[keyof DeleteProjectResponses];

export type GetProjectData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}';
};

export type GetProjectErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetProjectResponses = {
    /**
     * Expected response to a valid request
     */
    200: Project;
};

export type GetProjectResponse = GetProjectResponses[keyof GetProjectResponses];

export type ModifyProjectData = {
    /**
     * Modified project fields
     */
    body?: EditableProject;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}';
};

export type ModifyProjectErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyProjectError = ModifyProjectErrors[keyof ModifyProjectErrors];

export type ModifyProjectResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyProjectResponse = ModifyProjectResponses[keyof ModifyProjectResponses];

export type GetProjectsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs and/or slugs of the projects
         */
        ids: string;
    };
    url: '/projects';
};

export type GetProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Project>;
};

export type GetProjectsResponse = GetProjectsResponses[keyof GetProjectsResponses];

export type PatchProjectsData = {
    /**
     * Fields to edit on all projects specified
     */
    body?: PatchProjectsBody;
    path?: never;
    query: {
        /**
         * The IDs and/or slugs of the projects
         */
        ids: string;
    };
    url: '/projects';
};

export type PatchProjectsErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type PatchProjectsError = PatchProjectsErrors[keyof PatchProjectsErrors];

export type PatchProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type PatchProjectsResponse = PatchProjectsResponses[keyof PatchProjectsResponses];

export type RandomProjectsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The number of random projects to return
         */
        count: number;
    };
    url: '/projects_random';
};

export type RandomProjectsErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
};

export type RandomProjectsError = RandomProjectsErrors[keyof RandomProjectsErrors];

export type RandomProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Project>;
};

export type RandomProjectsResponse = RandomProjectsResponses[keyof RandomProjectsResponses];

export type CreateProjectData = {
    /**
     * New project
     */
    body?: CreateProjectBody;
    path?: never;
    query?: never;
    url: '/project';
};

export type CreateProjectErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type CreateProjectError = CreateProjectErrors[keyof CreateProjectErrors];

export type CreateProjectResponses = {
    /**
     * Expected response to a valid request
     */
    200: Project;
};

export type CreateProjectResponse = CreateProjectResponses[keyof CreateProjectResponses];

export type DeleteProjectIconData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/icon';
};

export type DeleteProjectIconErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type DeleteProjectIconError = DeleteProjectIconErrors[keyof DeleteProjectIconErrors];

export type DeleteProjectIconResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteProjectIconResponse = DeleteProjectIconResponses[keyof DeleteProjectIconResponses];

export type ChangeProjectIconData = {
    body?: Image;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query: {
        /**
         * Image extension
         */
        ext: 'png' | 'jpg' | 'jpeg' | 'bmp' | 'gif' | 'webp' | 'svg' | 'svgz' | 'rgb';
    };
    url: '/project/{id|slug}/icon';
};

export type ChangeProjectIconErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
};

export type ChangeProjectIconError = ChangeProjectIconErrors[keyof ChangeProjectIconErrors];

export type ChangeProjectIconResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ChangeProjectIconResponse = ChangeProjectIconResponses[keyof ChangeProjectIconResponses];

export type CheckProjectValidityData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/check';
};

export type CheckProjectValidityErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type CheckProjectValidityResponses = {
    /**
     * Expected response to a valid request
     */
    200: ProjectIdentifier;
};

export type CheckProjectValidityResponse = CheckProjectValidityResponses[keyof CheckProjectValidityResponses];

export type DeleteGalleryImageData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query: {
        /**
         * URL link of the image to delete
         */
        url: string;
    };
    url: '/project/{id|slug}/gallery';
};

export type DeleteGalleryImageErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type DeleteGalleryImageError = DeleteGalleryImageErrors[keyof DeleteGalleryImageErrors];

export type DeleteGalleryImageResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteGalleryImageResponse = DeleteGalleryImageResponses[keyof DeleteGalleryImageResponses];

export type ModifyGalleryImageData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query: {
        /**
         * URL link of the image to modify
         */
        url: string;
        /**
         * Whether the image is featured
         */
        featured?: boolean;
        /**
         * New title of the image
         */
        title?: string;
        /**
         * New description of the image
         */
        description?: string;
        /**
         * New ordering of the image
         */
        ordering?: number;
    };
    url: '/project/{id|slug}/gallery';
};

export type ModifyGalleryImageErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyGalleryImageError = ModifyGalleryImageErrors[keyof ModifyGalleryImageErrors];

export type ModifyGalleryImageResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyGalleryImageResponse = ModifyGalleryImageResponses[keyof ModifyGalleryImageResponses];

export type AddGalleryImageData = {
    body?: Image;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query: {
        /**
         * Image extension
         */
        ext: 'png' | 'jpg' | 'jpeg' | 'bmp' | 'gif' | 'webp' | 'svg' | 'svgz' | 'rgb';
        /**
         * Whether an image is featured
         */
        featured: boolean;
        /**
         * Title of the image
         */
        title?: string;
        /**
         * Description of the image
         */
        description?: string;
        /**
         * Ordering of the image
         */
        ordering?: number;
    };
    url: '/project/{id|slug}/gallery';
};

export type AddGalleryImageErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type AddGalleryImageError = AddGalleryImageErrors[keyof AddGalleryImageErrors];

export type AddGalleryImageResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type AddGalleryImageResponse = AddGalleryImageResponses[keyof AddGalleryImageResponses];

export type GetDependenciesData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/dependencies';
};

export type GetDependenciesErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetDependenciesResponses = {
    /**
     * Expected response to a valid request
     */
    200: ProjectDependencyList;
};

export type GetDependenciesResponse = GetDependenciesResponses[keyof GetDependenciesResponses];

export type UnfollowProjectData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/follow';
};

export type UnfollowProjectErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type UnfollowProjectError = UnfollowProjectErrors[keyof UnfollowProjectErrors];

export type UnfollowProjectResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type UnfollowProjectResponse = UnfollowProjectResponses[keyof UnfollowProjectResponses];

export type FollowProjectData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/follow';
};

export type FollowProjectErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type FollowProjectError = FollowProjectErrors[keyof FollowProjectErrors];

export type FollowProjectResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type FollowProjectResponse = FollowProjectResponses[keyof FollowProjectResponses];

export type ScheduleProjectData = {
    /**
     * Information about date and requested status
     */
    body?: Schedule;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/schedule';
};

export type ScheduleProjectErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type ScheduleProjectError = ScheduleProjectErrors[keyof ScheduleProjectErrors];

export type ScheduleProjectResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ScheduleProjectResponse = ScheduleProjectResponses[keyof ScheduleProjectResponses];

export type GetProjectVersionsData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: {
        /**
         * The types of loaders to filter for
         */
        loaders?: string;
        /**
         * The game versions to filter for
         */
        game_versions?: string;
        /**
         * Allows to filter for featured or non-featured versions only
         */
        featured?: boolean;
    };
    url: '/project/{id|slug}/version';
};

export type GetProjectVersionsErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetProjectVersionsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Version>;
};

export type GetProjectVersionsResponse = GetProjectVersionsResponses[keyof GetProjectVersionsResponses];

export type DeleteVersionData = {
    body?: never;
    path: {
        /**
         * The ID of the version
         */
        id: string;
    };
    query?: never;
    url: '/version/{id}';
};

export type DeleteVersionErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteVersionError = DeleteVersionErrors[keyof DeleteVersionErrors];

export type DeleteVersionResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteVersionResponse = DeleteVersionResponses[keyof DeleteVersionResponses];

export type GetVersionData = {
    body?: never;
    path: {
        /**
         * The ID of the version
         */
        id: string;
    };
    query?: never;
    url: '/version/{id}';
};

export type GetVersionErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetVersionResponses = {
    /**
     * Expected response to a valid request
     */
    200: Version;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type ModifyVersionData = {
    /**
     * Modified version fields
     */
    body?: EditableVersion;
    path: {
        /**
         * The ID of the version
         */
        id: string;
    };
    query?: never;
    url: '/version/{id}';
};

export type ModifyVersionErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyVersionError = ModifyVersionErrors[keyof ModifyVersionErrors];

export type ModifyVersionResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyVersionResponse = ModifyVersionResponses[keyof ModifyVersionResponses];

export type GetVersionFromIdOrNumberData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
        /**
         * The version ID or version number
         */
        'id|number': string;
    };
    query?: never;
    url: '/project/{id|slug}/version/{id|number}';
};

export type GetVersionFromIdOrNumberErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetVersionFromIdOrNumberResponses = {
    /**
     * Expected response to a valid request
     */
    200: Version;
};

export type GetVersionFromIdOrNumberResponse = GetVersionFromIdOrNumberResponses[keyof GetVersionFromIdOrNumberResponses];

export type CreateVersionData = {
    /**
     * New version
     */
    body?: CreateVersionBody;
    path?: never;
    query?: never;
    url: '/version';
};

export type CreateVersionErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type CreateVersionError = CreateVersionErrors[keyof CreateVersionErrors];

export type CreateVersionResponses = {
    /**
     * Expected response to a valid request
     */
    200: Version;
};

export type CreateVersionResponse = CreateVersionResponses[keyof CreateVersionResponses];

export type ScheduleVersionData = {
    /**
     * Information about date and requested status
     */
    body?: Schedule;
    path: {
        /**
         * The ID of the version
         */
        id: string;
    };
    query?: never;
    url: '/version/{id}/schedule';
};

export type ScheduleVersionErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type ScheduleVersionError = ScheduleVersionErrors[keyof ScheduleVersionErrors];

export type ScheduleVersionResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ScheduleVersionResponse = ScheduleVersionResponses[keyof ScheduleVersionResponses];

export type GetVersionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the versions
         */
        ids: string;
    };
    url: '/versions';
};

export type GetVersionsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Version>;
};

export type GetVersionsResponse = GetVersionsResponses[keyof GetVersionsResponses];

export type AddFilesToVersionData = {
    /**
     * New version files
     */
    body?: {
        data?: unknown;
    };
    path: {
        /**
         * The ID of the version
         */
        id: string;
    };
    query?: never;
    url: '/version/{id}/file';
};

export type AddFilesToVersionErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type AddFilesToVersionError = AddFilesToVersionErrors[keyof AddFilesToVersionErrors];

export type AddFilesToVersionResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type AddFilesToVersionResponse = AddFilesToVersionResponses[keyof AddFilesToVersionResponses];

export type DeleteFileFromHashData = {
    body?: never;
    path: {
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
    };
    query: {
        /**
         * The algorithm of the hash
         */
        algorithm: 'sha1' | 'sha512';
        /**
         * Version ID to delete the version from, if multiple files of the same hash exist
         */
        version_id?: string;
    };
    url: '/version_file/{hash}';
};

export type DeleteFileFromHashErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteFileFromHashError = DeleteFileFromHashErrors[keyof DeleteFileFromHashErrors];

export type DeleteFileFromHashResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteFileFromHashResponse = DeleteFileFromHashResponses[keyof DeleteFileFromHashResponses];

export type VersionFromHashData = {
    body?: never;
    path: {
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
    };
    query: {
        /**
         * The algorithm of the hash
         */
        algorithm: 'sha1' | 'sha512';
        /**
         * Whether to return multiple results when looking for this hash
         */
        multiple?: boolean;
    };
    url: '/version_file/{hash}';
};

export type VersionFromHashErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type VersionFromHashResponses = {
    /**
     * Expected response to a valid request
     */
    200: Version;
};

export type VersionFromHashResponse = VersionFromHashResponses[keyof VersionFromHashResponses];

export type GetLatestVersionFromHashData = {
    /**
     * Parameters of the updated version requested
     */
    body?: GetLatestVersionFromHashBody;
    path: {
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
    };
    query: {
        /**
         * The algorithm of the hash
         */
        algorithm: 'sha1' | 'sha512';
    };
    url: '/version_file/{hash}/update';
};

export type GetLatestVersionFromHashErrors = {
    /**
     * Request was invalid, see given error
     */
    400: unknown;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetLatestVersionFromHashResponses = {
    /**
     * Expected response to a valid request
     */
    200: Version;
};

export type GetLatestVersionFromHashResponse = GetLatestVersionFromHashResponses[keyof GetLatestVersionFromHashResponses];

export type VersionsFromHashesData = {
    /**
     * Hashes and algorithm of the versions requested
     */
    body?: HashList;
    path?: never;
    query?: never;
    url: '/version_files';
};

export type VersionsFromHashesErrors = {
    /**
     * Request was invalid, see given error
     */
    400: unknown;
};

export type VersionsFromHashesResponses = {
    /**
     * Expected response to a valid request
     */
    200: HashVersionMap;
};

export type VersionsFromHashesResponse = VersionsFromHashesResponses[keyof VersionsFromHashesResponses];

export type GetLatestVersionsFromHashesData = {
    /**
     * Parameters of the updated version requested
     */
    body?: GetLatestVersionsFromHashesBody;
    path?: never;
    query?: never;
    url: '/version_files/update';
};

export type GetLatestVersionsFromHashesErrors = {
    /**
     * Request was invalid, see given error
     */
    400: unknown;
};

export type GetLatestVersionsFromHashesResponses = {
    /**
     * Expected response to a valid request
     */
    200: HashVersionMap;
};

export type GetLatestVersionsFromHashesResponse = GetLatestVersionsFromHashesResponses[keyof GetLatestVersionsFromHashesResponses];

export type GetUserData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}';
};

export type GetUserErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetUserResponses = {
    /**
     * Expected response to a valid request
     */
    200: User;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type ModifyUserData = {
    /**
     * Modified user fields
     */
    body?: EditableUser;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}';
};

export type ModifyUserErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyUserError = ModifyUserErrors[keyof ModifyUserErrors];

export type ModifyUserResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyUserResponse = ModifyUserResponses[keyof ModifyUserResponses];

export type GetUserFromAuthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type GetUserFromAuthErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type GetUserFromAuthError = GetUserFromAuthErrors[keyof GetUserFromAuthErrors];

export type GetUserFromAuthResponses = {
    /**
     * Expected response to a valid request
     */
    200: User;
};

export type GetUserFromAuthResponse = GetUserFromAuthResponses[keyof GetUserFromAuthResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the users
         */
        ids: string;
    };
    url: '/users';
};

export type GetUsersResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<User>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type DeleteUserIconData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/icon';
};

export type DeleteUserIconErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteUserIconError = DeleteUserIconErrors[keyof DeleteUserIconErrors];

export type DeleteUserIconResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteUserIconResponse = DeleteUserIconResponses[keyof DeleteUserIconResponses];

export type ChangeUserIconData = {
    body?: Image;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/icon';
};

export type ChangeUserIconErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ChangeUserIconError = ChangeUserIconErrors[keyof ChangeUserIconErrors];

export type ChangeUserIconResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ChangeUserIconResponse = ChangeUserIconResponses[keyof ChangeUserIconResponses];

export type GetUserProjectsData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/projects';
};

export type GetUserProjectsErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetUserProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Project>;
};

export type GetUserProjectsResponse = GetUserProjectsResponses[keyof GetUserProjectsResponses];

export type GetFollowedProjectsData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/follows';
};

export type GetFollowedProjectsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetFollowedProjectsError = GetFollowedProjectsErrors[keyof GetFollowedProjectsErrors];

export type GetFollowedProjectsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Project>;
};

export type GetFollowedProjectsResponse = GetFollowedProjectsResponses[keyof GetFollowedProjectsResponses];

export type GetPayoutHistoryData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/payouts';
};

export type GetPayoutHistoryErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetPayoutHistoryError = GetPayoutHistoryErrors[keyof GetPayoutHistoryErrors];

export type GetPayoutHistoryResponses = {
    /**
     * Expected response to a valid request
     */
    200: UserPayoutHistory;
};

export type GetPayoutHistoryResponse = GetPayoutHistoryResponses[keyof GetPayoutHistoryResponses];

export type WithdrawPayoutData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query: {
        /**
         * Amount to withdraw
         */
        amount: number;
    };
    url: '/user/{id|username}/payouts';
};

export type WithdrawPayoutErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type WithdrawPayoutError = WithdrawPayoutErrors[keyof WithdrawPayoutErrors];

export type WithdrawPayoutResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type WithdrawPayoutResponse = WithdrawPayoutResponses[keyof WithdrawPayoutResponses];

export type GetUserNotificationsData = {
    body?: never;
    path: {
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/user/{id|username}/notifications';
};

export type GetUserNotificationsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetUserNotificationsError = GetUserNotificationsErrors[keyof GetUserNotificationsErrors];

export type GetUserNotificationsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Notification>;
};

export type GetUserNotificationsResponse = GetUserNotificationsResponses[keyof GetUserNotificationsResponses];

export type DeleteNotificationData = {
    body?: never;
    path: {
        /**
         * The ID of the notification
         */
        id: string;
    };
    query?: never;
    url: '/notification/{id}';
};

export type DeleteNotificationErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteNotificationError = DeleteNotificationErrors[keyof DeleteNotificationErrors];

export type DeleteNotificationResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteNotificationResponse = DeleteNotificationResponses[keyof DeleteNotificationResponses];

export type GetNotificationData = {
    body?: never;
    path: {
        /**
         * The ID of the notification
         */
        id: string;
    };
    query?: never;
    url: '/notification/{id}';
};

export type GetNotificationErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetNotificationError = GetNotificationErrors[keyof GetNotificationErrors];

export type GetNotificationResponses = {
    /**
     * Expected response to a valid request
     */
    200: Notification;
};

export type GetNotificationResponse = GetNotificationResponses[keyof GetNotificationResponses];

export type ReadNotificationData = {
    body?: never;
    path: {
        /**
         * The ID of the notification
         */
        id: string;
    };
    query?: never;
    url: '/notification/{id}';
};

export type ReadNotificationErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ReadNotificationError = ReadNotificationErrors[keyof ReadNotificationErrors];

export type ReadNotificationResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ReadNotificationResponse = ReadNotificationResponses[keyof ReadNotificationResponses];

export type DeleteNotificationsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the notifications
         */
        ids: string;
    };
    url: '/notifications';
};

export type DeleteNotificationsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteNotificationsError = DeleteNotificationsErrors[keyof DeleteNotificationsErrors];

export type DeleteNotificationsResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteNotificationsResponse = DeleteNotificationsResponses[keyof DeleteNotificationsResponses];

export type GetNotificationsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the notifications
         */
        ids: string;
    };
    url: '/notifications';
};

export type GetNotificationsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetNotificationsError = GetNotificationsErrors[keyof GetNotificationsErrors];

export type GetNotificationsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Notification>;
};

export type GetNotificationsResponse = GetNotificationsResponses[keyof GetNotificationsResponses];

export type ReadNotificationsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the notifications
         */
        ids: string;
    };
    url: '/notifications';
};

export type ReadNotificationsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ReadNotificationsError = ReadNotificationsErrors[keyof ReadNotificationsErrors];

export type ReadNotificationsResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ReadNotificationsResponse = ReadNotificationsResponses[keyof ReadNotificationsResponses];

export type GetOpenReportsData = {
    body?: never;
    path?: never;
    query?: {
        count?: number;
    };
    url: '/report';
};

export type GetOpenReportsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetOpenReportsError = GetOpenReportsErrors[keyof GetOpenReportsErrors];

export type GetOpenReportsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Report>;
};

export type GetOpenReportsResponse = GetOpenReportsResponses[keyof GetOpenReportsResponses];

export type SubmitReportData = {
    /**
     * The report to be sent
     */
    body?: CreatableReport;
    path?: never;
    query?: never;
    url: '/report';
};

export type SubmitReportErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
};

export type SubmitReportError = SubmitReportErrors[keyof SubmitReportErrors];

export type SubmitReportResponses = {
    /**
     * Expected response to a valid request
     */
    200: Report;
};

export type SubmitReportResponse = SubmitReportResponses[keyof SubmitReportResponses];

export type GetReportData = {
    body?: never;
    path: {
        /**
         * The ID of the report
         */
        id: string;
    };
    query?: never;
    url: '/report/{id}';
};

export type GetReportErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetReportError = GetReportErrors[keyof GetReportErrors];

export type GetReportResponses = {
    /**
     * Expected response to a valid request
     */
    200: Report;
};

export type GetReportResponse = GetReportResponses[keyof GetReportResponses];

export type ModifyReportData = {
    /**
     * What to modify about the report
     */
    body?: {
        /**
         * The contents of the report
         */
        body?: string;
        /**
         * Whether the thread should be closed
         */
        closed?: boolean;
    };
    path: {
        /**
         * The ID of the report
         */
        id: string;
    };
    query?: never;
    url: '/report/{id}';
};

export type ModifyReportErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyReportError = ModifyReportErrors[keyof ModifyReportErrors];

export type ModifyReportResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyReportResponse = ModifyReportResponses[keyof ModifyReportResponses];

export type GetReportsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the reports
         */
        ids: string;
    };
    url: '/reports';
};

export type GetReportsErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetReportsError = GetReportsErrors[keyof GetReportsErrors];

export type GetReportsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Report>;
};

export type GetReportsResponse = GetReportsResponses[keyof GetReportsResponses];

export type GetThreadData = {
    body?: never;
    path: {
        /**
         * The ID of the thread
         */
        id: string;
    };
    query?: never;
    url: '/thread/{id}';
};

export type GetThreadErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetThreadResponses = {
    /**
     * Expected response to a valid request
     */
    200: Thread;
};

export type GetThreadResponse = GetThreadResponses[keyof GetThreadResponses];

export type SendThreadMessageData = {
    /**
     * The message to be sent. Note that you only need the fields applicable for the `text` type.
     */
    body?: ThreadMessageBody;
    path: {
        /**
         * The ID of the thread
         */
        id: string;
    };
    query?: never;
    url: '/thread/{id}';
};

export type SendThreadMessageErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type SendThreadMessageError = SendThreadMessageErrors[keyof SendThreadMessageErrors];

export type SendThreadMessageResponses = {
    /**
     * Expected response to a valid request
     */
    200: Thread;
};

export type SendThreadMessageResponse = SendThreadMessageResponses[keyof SendThreadMessageResponses];

export type GetThreadsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the threads
         */
        ids: string;
    };
    url: '/threads';
};

export type GetThreadsErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetThreadsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Thread>;
};

export type GetThreadsResponse = GetThreadsResponses[keyof GetThreadsResponses];

export type DeleteThreadMessageData = {
    body?: never;
    path: {
        /**
         * The ID of the message
         */
        id: string;
    };
    query?: never;
    url: '/message/{id}';
};

export type DeleteThreadMessageErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteThreadMessageError = DeleteThreadMessageErrors[keyof DeleteThreadMessageErrors];

export type DeleteThreadMessageResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteThreadMessageResponse = DeleteThreadMessageResponses[keyof DeleteThreadMessageResponses];

export type GetProjectTeamMembersData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: never;
    url: '/project/{id|slug}/members';
};

export type GetProjectTeamMembersErrors = {
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type GetProjectTeamMembersResponses = {
    /**
     * An array of team members
     */
    200: Array<TeamMember>;
};

export type GetProjectTeamMembersResponse = GetProjectTeamMembersResponses[keyof GetProjectTeamMembersResponses];

export type GetTeamMembersData = {
    body?: never;
    path: {
        /**
         * The ID of the team
         */
        id: string;
    };
    query?: never;
    url: '/team/{id}/members';
};

export type GetTeamMembersResponses = {
    /**
     * An array of team members
     */
    200: Array<TeamMember>;
};

export type GetTeamMembersResponse = GetTeamMembersResponses[keyof GetTeamMembersResponses];

export type AddTeamMemberData = {
    /**
     * User to be added (must be the ID, usernames cannot be used here)
     */
    body?: UserIdentifier;
    path: {
        /**
         * The ID of the team
         */
        id: string;
    };
    query?: never;
    url: '/team/{id}/members';
};

export type AddTeamMemberErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type AddTeamMemberError = AddTeamMemberErrors[keyof AddTeamMemberErrors];

export type AddTeamMemberResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type AddTeamMemberResponse = AddTeamMemberResponses[keyof AddTeamMemberResponses];

export type GetTeamsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The IDs of the teams
         */
        ids: string;
    };
    url: '/teams';
};

export type GetTeamsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<Array<TeamMember>>;
};

export type GetTeamsResponse = GetTeamsResponses[keyof GetTeamsResponses];

export type JoinTeamData = {
    body?: never;
    path: {
        /**
         * The ID of the team
         */
        id: string;
    };
    query?: never;
    url: '/team/{id}/join';
};

export type JoinTeamErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type JoinTeamError = JoinTeamErrors[keyof JoinTeamErrors];

export type JoinTeamResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type JoinTeamResponse = JoinTeamResponses[keyof JoinTeamResponses];

export type DeleteTeamMemberData = {
    body?: never;
    path: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/team/{id}/members/{id|username}';
};

export type DeleteTeamMemberErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type DeleteTeamMemberError = DeleteTeamMemberErrors[keyof DeleteTeamMemberErrors];

export type DeleteTeamMemberResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type DeleteTeamMemberResponse = DeleteTeamMemberResponses[keyof DeleteTeamMemberResponses];

export type ModifyTeamMemberData = {
    /**
     * Contents to be modified
     */
    body?: ModifyTeamMemberBody;
    path: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * The ID or username of the user
         */
        'id|username': string;
    };
    query?: never;
    url: '/team/{id}/members/{id|username}';
};

export type ModifyTeamMemberErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type ModifyTeamMemberError = ModifyTeamMemberErrors[keyof ModifyTeamMemberErrors];

export type ModifyTeamMemberResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type ModifyTeamMemberResponse = ModifyTeamMemberResponses[keyof ModifyTeamMemberResponses];

export type TransferTeamOwnershipData = {
    /**
     * New owner's ID
     */
    body?: UserIdentifier;
    path: {
        /**
         * The ID of the team
         */
        id: string;
    };
    query?: never;
    url: '/team/{id}/owner';
};

export type TransferTeamOwnershipErrors = {
    /**
     * Incorrect token scopes or no authorization to access the requested item(s)
     */
    401: AuthError;
    /**
     * The requested item(s) were not found or no authorization to access the requested item(s)
     */
    404: unknown;
};

export type TransferTeamOwnershipError = TransferTeamOwnershipErrors[keyof TransferTeamOwnershipErrors];

export type TransferTeamOwnershipResponses = {
    /**
     * Expected response to a valid request
     */
    204: void;
};

export type TransferTeamOwnershipResponse = TransferTeamOwnershipResponses[keyof TransferTeamOwnershipResponses];

export type CategoryListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/category';
};

export type CategoryListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<CategoryTag>;
};

export type CategoryListResponse = CategoryListResponses[keyof CategoryListResponses];

export type LoaderListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/loader';
};

export type LoaderListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<LoaderTag>;
};

export type LoaderListResponse = LoaderListResponses[keyof LoaderListResponses];

export type VersionListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/game_version';
};

export type VersionListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<GameVersionTag>;
};

export type VersionListResponse = VersionListResponses[keyof VersionListResponses];

export type LicenseListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/license';
};

export type LicenseListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<LicenseTag>;
};

export type LicenseListResponse = LicenseListResponses[keyof LicenseListResponses];

export type LicenseTextData = {
    body?: never;
    path: {
        /**
         * The license ID to get the text of
         */
        id: string;
    };
    query?: never;
    url: '/tag/license/{id}';
};

export type LicenseTextErrors = {
    /**
     * Request was invalid, see given error
     */
    400: InvalidInputError;
};

export type LicenseTextError = LicenseTextErrors[keyof LicenseTextErrors];

export type LicenseTextResponses = {
    /**
     * Expected response to a valid request
     */
    200: License;
};

export type LicenseTextResponse = LicenseTextResponses[keyof LicenseTextResponses];

export type DonationPlatformListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/donation_platform';
};

export type DonationPlatformListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<DonationPlatformTag>;
};

export type DonationPlatformListResponse = DonationPlatformListResponses[keyof DonationPlatformListResponses];

export type ReportTypeListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/report_type';
};

export type ReportTypeListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<string>;
};

export type ReportTypeListResponse = ReportTypeListResponses[keyof ReportTypeListResponses];

export type ProjectTypeListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/project_type';
};

export type ProjectTypeListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<string>;
};

export type ProjectTypeListResponse = ProjectTypeListResponses[keyof ProjectTypeListResponses];

export type SideTypeListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tag/side_type';
};

export type SideTypeListResponses = {
    /**
     * Expected response to a valid request
     */
    200: Array<string>;
};

export type SideTypeListResponse = SideTypeListResponses[keyof SideTypeListResponses];

export type ForgeUpdatesData = {
    body?: never;
    path: {
        /**
         * The ID or slug of the project
         */
        'id|slug': string;
    };
    query?: {
        /**
         * Whether to include NeoForge versions. Can be `only` (NeoForge-only versions), `include` (both Forge and NeoForge versions), or omitted (Forge-only versions).
         */
        neoforge?: 'only' | 'include';
    };
    url: '/updates/{id|slug}/forge_updates.json';
};

export type ForgeUpdatesErrors = {
    /**
     * Invalid request
     */
    400: InvalidInputError;
};

export type ForgeUpdatesError = ForgeUpdatesErrors[keyof ForgeUpdatesErrors];

export type ForgeUpdatesResponses = {
    /**
     * Expected response to a valid request
     */
    200: ForgeUpdates;
};

export type ForgeUpdatesResponse = ForgeUpdatesResponses[keyof ForgeUpdatesResponses];

export type StatisticsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/statistics';
};

export type StatisticsResponses = {
    /**
     * Expected response to a valid request
     */
    200: Statistics;
};

export type StatisticsResponse = StatisticsResponses[keyof StatisticsResponses];
