// This file is auto-generated by @hey-api/openapi-ts

import { type Client, formDataBodySerializer, type Options as Options2, type TDataShape } from './client';
import { client } from './client.gen';
import type { AddFilesToVersionData, AddFilesToVersionErrors, AddFilesToVersionResponses, AddGalleryImageData, AddGalleryImageErrors, AddGalleryImageResponses, AddTeamMemberData, AddTeamMemberErrors, AddTeamMemberResponses, CategoryListData, CategoryListResponses, ChangeProjectIconData, ChangeProjectIconErrors, ChangeProjectIconResponses, ChangeUserIconData, ChangeUserIconErrors, ChangeUserIconResponses, CheckProjectValidityData, CheckProjectValidityErrors, CheckProjectValidityResponses, CreateProjectData, CreateProjectErrors, CreateProjectResponses, CreateVersionData, CreateVersionErrors, CreateVersionResponses, DeleteFileFromHashData, DeleteFileFromHashErrors, DeleteFileFromHashResponses, DeleteGalleryImageData, DeleteGalleryImageErrors, DeleteGalleryImageResponses, DeleteNotificationData, DeleteNotificationErrors, DeleteNotificationResponses, DeleteNotificationsData, DeleteNotificationsErrors, DeleteNotificationsResponses, DeleteProjectData, DeleteProjectErrors, DeleteProjectIconData, DeleteProjectIconErrors, DeleteProjectIconResponses, DeleteProjectResponses, DeleteTeamMemberData, DeleteTeamMemberErrors, DeleteTeamMemberResponses, DeleteThreadMessageData, DeleteThreadMessageErrors, DeleteThreadMessageResponses, DeleteUserIconData, DeleteUserIconErrors, DeleteUserIconResponses, DeleteVersionData, DeleteVersionErrors, DeleteVersionResponses, DonationPlatformListData, DonationPlatformListResponses, FollowProjectData, FollowProjectErrors, FollowProjectResponses, ForgeUpdatesData, ForgeUpdatesErrors, ForgeUpdatesResponses, GetDependenciesData, GetDependenciesErrors, GetDependenciesResponses, GetFollowedProjectsData, GetFollowedProjectsErrors, GetFollowedProjectsResponses, GetLatestVersionFromHashData, GetLatestVersionFromHashErrors, GetLatestVersionFromHashResponses, GetLatestVersionsFromHashesData, GetLatestVersionsFromHashesErrors, GetLatestVersionsFromHashesResponses, GetNotificationData, GetNotificationErrors, GetNotificationResponses, GetNotificationsData, GetNotificationsErrors, GetNotificationsResponses, GetOpenReportsData, GetOpenReportsErrors, GetOpenReportsResponses, GetPayoutHistoryData, GetPayoutHistoryErrors, GetPayoutHistoryResponses, GetProjectData, GetProjectErrors, GetProjectResponses, GetProjectsData, GetProjectsResponses, GetProjectTeamMembersData, GetProjectTeamMembersErrors, GetProjectTeamMembersResponses, GetProjectVersionsData, GetProjectVersionsErrors, GetProjectVersionsResponses, GetReportData, GetReportErrors, GetReportResponses, GetReportsData, GetReportsErrors, GetReportsResponses, GetTeamMembersData, GetTeamMembersResponses, GetTeamsData, GetTeamsResponses, GetThreadData, GetThreadErrors, GetThreadResponses, GetThreadsData, GetThreadsErrors, GetThreadsResponses, GetUserData, GetUserErrors, GetUserFromAuthData, GetUserFromAuthErrors, GetUserFromAuthResponses, GetUserNotificationsData, GetUserNotificationsErrors, GetUserNotificationsResponses, GetUserProjectsData, GetUserProjectsErrors, GetUserProjectsResponses, GetUserResponses, GetUsersData, GetUsersResponses, GetVersionData, GetVersionErrors, GetVersionFromIdOrNumberData, GetVersionFromIdOrNumberErrors, GetVersionFromIdOrNumberResponses, GetVersionResponses, GetVersionsData, GetVersionsResponses, JoinTeamData, JoinTeamErrors, JoinTeamResponses, LicenseListData, LicenseListResponses, LicenseTextData, LicenseTextErrors, LicenseTextResponses, LoaderListData, LoaderListResponses, ModifyGalleryImageData, ModifyGalleryImageErrors, ModifyGalleryImageResponses, ModifyProjectData, ModifyProjectErrors, ModifyProjectResponses, ModifyReportData, ModifyReportErrors, ModifyReportResponses, ModifyTeamMemberData, ModifyTeamMemberErrors, ModifyTeamMemberResponses, ModifyUserData, ModifyUserErrors, ModifyUserResponses, ModifyVersionData, ModifyVersionErrors, ModifyVersionResponses, PatchProjectsData, PatchProjectsErrors, PatchProjectsResponses, ProjectTypeListData, ProjectTypeListResponses, RandomProjectsData, RandomProjectsErrors, RandomProjectsResponses, ReadNotificationData, ReadNotificationErrors, ReadNotificationResponses, ReadNotificationsData, ReadNotificationsErrors, ReadNotificationsResponses, ReportTypeListData, ReportTypeListResponses, ScheduleProjectData, ScheduleProjectErrors, ScheduleProjectResponses, ScheduleVersionData, ScheduleVersionErrors, ScheduleVersionResponses, SearchProjectsData, SearchProjectsErrors, SearchProjectsResponses, SendThreadMessageData, SendThreadMessageErrors, SendThreadMessageResponses, SideTypeListData, SideTypeListResponses, StatisticsData, StatisticsResponses, SubmitReportData, SubmitReportErrors, SubmitReportResponses, TransferTeamOwnershipData, TransferTeamOwnershipErrors, TransferTeamOwnershipResponses, UnfollowProjectData, UnfollowProjectErrors, UnfollowProjectResponses, VersionFromHashData, VersionFromHashErrors, VersionFromHashResponses, VersionListData, VersionListResponses, VersionsFromHashesData, VersionsFromHashesErrors, VersionsFromHashesResponses, WithdrawPayoutData, WithdrawPayoutErrors, WithdrawPayoutResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Search projects
 */
export const searchProjects = <ThrowOnError extends boolean = false>(options?: Options<SearchProjectsData, ThrowOnError>) => {
    return (options?.client ?? client).get<SearchProjectsResponses, SearchProjectsErrors, ThrowOnError>({
        url: '/search',
        ...options
    });
};

/**
 * Delete a project
 */
export const deleteProject = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteProjectResponses, DeleteProjectErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}',
        ...options
    });
};

/**
 * Get a project
 */
export const getProject = <ThrowOnError extends boolean = false>(options: Options<GetProjectData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProjectResponses, GetProjectErrors, ThrowOnError>({
        url: '/project/{id|slug}',
        ...options
    });
};

/**
 * Modify a project
 */
export const modifyProject = <ThrowOnError extends boolean = false>(options: Options<ModifyProjectData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyProjectResponses, ModifyProjectErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get multiple projects
 */
export const getProjects = <ThrowOnError extends boolean = false>(options: Options<GetProjectsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProjectsResponses, unknown, ThrowOnError>({
        url: '/projects',
        ...options
    });
};

/**
 * Bulk-edit multiple projects
 */
export const patchProjects = <ThrowOnError extends boolean = false>(options: Options<PatchProjectsData, ThrowOnError>) => {
    return (options.client ?? client).patch<PatchProjectsResponses, PatchProjectsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/projects',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get a list of random projects
 */
export const randomProjects = <ThrowOnError extends boolean = false>(options: Options<RandomProjectsData, ThrowOnError>) => {
    return (options.client ?? client).get<RandomProjectsResponses, RandomProjectsErrors, ThrowOnError>({
        url: '/projects_random',
        ...options
    });
};

/**
 * Create a project
 */
export const createProject = <ThrowOnError extends boolean = false>(options?: Options<CreateProjectData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateProjectResponses, CreateProjectErrors, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Delete project's icon
 */
export const deleteProjectIcon = <ThrowOnError extends boolean = false>(options: Options<DeleteProjectIconData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteProjectIconResponses, DeleteProjectIconErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/icon',
        ...options
    });
};

/**
 * Change project's icon
 *
 * The new icon may be up to 256KiB in size.
 */
export const changeProjectIcon = <ThrowOnError extends boolean = false>(options: Options<ChangeProjectIconData, ThrowOnError>) => {
    return (options.client ?? client).patch<ChangeProjectIconResponses, ChangeProjectIconErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/icon',
        ...options,
        headers: {
            'Content-Type': 'image/png',
            ...options.headers
        }
    });
};

/**
 * Check project slug/ID validity
 */
export const checkProjectValidity = <ThrowOnError extends boolean = false>(options: Options<CheckProjectValidityData, ThrowOnError>) => {
    return (options.client ?? client).get<CheckProjectValidityResponses, CheckProjectValidityErrors, ThrowOnError>({
        url: '/project/{id|slug}/check',
        ...options
    });
};

/**
 * Delete a gallery image
 */
export const deleteGalleryImage = <ThrowOnError extends boolean = false>(options: Options<DeleteGalleryImageData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteGalleryImageResponses, DeleteGalleryImageErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/gallery',
        ...options
    });
};

/**
 * Modify a gallery image
 */
export const modifyGalleryImage = <ThrowOnError extends boolean = false>(options: Options<ModifyGalleryImageData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyGalleryImageResponses, ModifyGalleryImageErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/gallery',
        ...options
    });
};

/**
 * Add a gallery image
 *
 * Modrinth allows you to upload files of up to 5MiB to a project's gallery.
 */
export const addGalleryImage = <ThrowOnError extends boolean = false>(options: Options<AddGalleryImageData, ThrowOnError>) => {
    return (options.client ?? client).post<AddGalleryImageResponses, AddGalleryImageErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/gallery',
        ...options,
        headers: {
            'Content-Type': 'image/png',
            ...options.headers
        }
    });
};

/**
 * Get all of a project's dependencies
 */
export const getDependencies = <ThrowOnError extends boolean = false>(options: Options<GetDependenciesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDependenciesResponses, GetDependenciesErrors, ThrowOnError>({
        url: '/project/{id|slug}/dependencies',
        ...options
    });
};

/**
 * Unfollow a project
 */
export const unfollowProject = <ThrowOnError extends boolean = false>(options: Options<UnfollowProjectData, ThrowOnError>) => {
    return (options.client ?? client).delete<UnfollowProjectResponses, UnfollowProjectErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/follow',
        ...options
    });
};

/**
 * Follow a project
 */
export const followProject = <ThrowOnError extends boolean = false>(options: Options<FollowProjectData, ThrowOnError>) => {
    return (options.client ?? client).post<FollowProjectResponses, FollowProjectErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/follow',
        ...options
    });
};

/**
 * Schedule a project
 */
export const scheduleProject = <ThrowOnError extends boolean = false>(options: Options<ScheduleProjectData, ThrowOnError>) => {
    return (options.client ?? client).post<ScheduleProjectResponses, ScheduleProjectErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/project/{id|slug}/schedule',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List project's versions
 */
export const getProjectVersions = <ThrowOnError extends boolean = false>(options: Options<GetProjectVersionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProjectVersionsResponses, GetProjectVersionsErrors, ThrowOnError>({
        url: '/project/{id|slug}/version',
        ...options
    });
};

/**
 * Delete a version
 */
export const deleteVersion = <ThrowOnError extends boolean = false>(options: Options<DeleteVersionData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteVersionResponses, DeleteVersionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version/{id}',
        ...options
    });
};

/**
 * Get a version
 */
export const getVersion = <ThrowOnError extends boolean = false>(options: Options<GetVersionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVersionResponses, GetVersionErrors, ThrowOnError>({
        url: '/version/{id}',
        ...options
    });
};

/**
 * Modify a version
 */
export const modifyVersion = <ThrowOnError extends boolean = false>(options: Options<ModifyVersionData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyVersionResponses, ModifyVersionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get a version given a version number or ID
 *
 * Please note that, if the version number provided matches multiple versions, only the **oldest matching version** will be returned.
 */
export const getVersionFromIdOrNumber = <ThrowOnError extends boolean = false>(options: Options<GetVersionFromIdOrNumberData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVersionFromIdOrNumberResponses, GetVersionFromIdOrNumberErrors, ThrowOnError>({
        url: '/project/{id|slug}/version/{id|number}',
        ...options
    });
};

/**
 * Create a version
 *
 * This route creates a version on an existing project. There must be at least one file attached to each new version, unless the new version's status is `draft`. `.mrpack`, `.jar`, `.zip`, and `.litemod` files are accepted.
 *
 * The request is a [multipart request](https://www.ietf.org/rfc/rfc2388.txt) with at least two form fields: one is `data`, which includes a JSON body with the version metadata as shown below, and at least one field containing an upload file.
 *
 * You can name the file parts anything you would like, but you must list each of the parts' names in `file_parts`, and optionally, provide one to use as the primary file in `primary_file`.
 *
 */
export const createVersion = <ThrowOnError extends boolean = false>(options?: Options<CreateVersionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateVersionResponses, CreateVersionErrors, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version',
        ...options,
        headers: {
            'Content-Type': null,
            ...options?.headers
        }
    });
};

/**
 * Schedule a version
 */
export const scheduleVersion = <ThrowOnError extends boolean = false>(options: Options<ScheduleVersionData, ThrowOnError>) => {
    return (options.client ?? client).post<ScheduleVersionResponses, ScheduleVersionErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version/{id}/schedule',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get multiple versions
 */
export const getVersions = <ThrowOnError extends boolean = false>(options: Options<GetVersionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVersionsResponses, unknown, ThrowOnError>({
        url: '/versions',
        ...options
    });
};

/**
 * Add files to version
 *
 * Project files are attached. `.mrpack` and `.jar` files are accepted.
 */
export const addFilesToVersion = <ThrowOnError extends boolean = false>(options: Options<AddFilesToVersionData, ThrowOnError>) => {
    return (options.client ?? client).post<AddFilesToVersionResponses, AddFilesToVersionErrors, ThrowOnError>({
        ...formDataBodySerializer,
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version/{id}/file',
        ...options,
        headers: {
            'Content-Type': null,
            ...options.headers
        }
    });
};

/**
 * Delete a file from its hash
 */
export const deleteFileFromHash = <ThrowOnError extends boolean = false>(options: Options<DeleteFileFromHashData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteFileFromHashResponses, DeleteFileFromHashErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/version_file/{hash}',
        ...options
    });
};

/**
 * Get version from hash
 */
export const versionFromHash = <ThrowOnError extends boolean = false>(options: Options<VersionFromHashData, ThrowOnError>) => {
    return (options.client ?? client).get<VersionFromHashResponses, VersionFromHashErrors, ThrowOnError>({
        url: '/version_file/{hash}',
        ...options
    });
};

/**
 * Latest version of a project from a hash, loader(s), and game version(s)
 */
export const getLatestVersionFromHash = <ThrowOnError extends boolean = false>(options: Options<GetLatestVersionFromHashData, ThrowOnError>) => {
    return (options.client ?? client).post<GetLatestVersionFromHashResponses, GetLatestVersionFromHashErrors, ThrowOnError>({
        url: '/version_file/{hash}/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get versions from hashes
 *
 * This is the same as [`/version_file/{hash}`](#operation/versionFromHash) except it accepts multiple hashes.
 */
export const versionsFromHashes = <ThrowOnError extends boolean = false>(options?: Options<VersionsFromHashesData, ThrowOnError>) => {
    return (options?.client ?? client).post<VersionsFromHashesResponses, VersionsFromHashesErrors, ThrowOnError>({
        url: '/version_files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Latest versions of multiple project from hashes, loader(s), and game version(s)
 *
 * This is the same as [`/version_file/{hash}/update`](#operation/getLatestVersionFromHash) except it accepts multiple hashes.
 */
export const getLatestVersionsFromHashes = <ThrowOnError extends boolean = false>(options?: Options<GetLatestVersionsFromHashesData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetLatestVersionsFromHashesResponses, GetLatestVersionsFromHashesErrors, ThrowOnError>({
        url: '/version_files/update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get a user
 */
export const getUser = <ThrowOnError extends boolean = false>(options: Options<GetUserData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserResponses, GetUserErrors, ThrowOnError>({
        url: '/user/{id|username}',
        ...options
    });
};

/**
 * Modify a user
 */
export const modifyUser = <ThrowOnError extends boolean = false>(options: Options<ModifyUserData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyUserResponses, ModifyUserErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get user from authorization header
 */
export const getUserFromAuth = <ThrowOnError extends boolean = false>(options?: Options<GetUserFromAuthData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUserFromAuthResponses, GetUserFromAuthErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user',
        ...options
    });
};

/**
 * Get multiple users
 */
export const getUsers = <ThrowOnError extends boolean = false>(options: Options<GetUsersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersResponses, unknown, ThrowOnError>({
        url: '/users',
        ...options
    });
};

/**
 * Remove user's avatar
 */
export const deleteUserIcon = <ThrowOnError extends boolean = false>(options: Options<DeleteUserIconData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUserIconResponses, DeleteUserIconErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/icon',
        ...options
    });
};

/**
 * Change user's avatar
 *
 * The new avatar may be up to 2MiB in size.
 */
export const changeUserIcon = <ThrowOnError extends boolean = false>(options: Options<ChangeUserIconData, ThrowOnError>) => {
    return (options.client ?? client).patch<ChangeUserIconResponses, ChangeUserIconErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/icon',
        ...options,
        headers: {
            'Content-Type': 'image/png',
            ...options.headers
        }
    });
};

/**
 * Get user's projects
 */
export const getUserProjects = <ThrowOnError extends boolean = false>(options: Options<GetUserProjectsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserProjectsResponses, GetUserProjectsErrors, ThrowOnError>({
        url: '/user/{id|username}/projects',
        ...options
    });
};

/**
 * Get user's followed projects
 */
export const getFollowedProjects = <ThrowOnError extends boolean = false>(options: Options<GetFollowedProjectsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetFollowedProjectsResponses, GetFollowedProjectsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/follows',
        ...options
    });
};

/**
 * Get user's payout history
 */
export const getPayoutHistory = <ThrowOnError extends boolean = false>(options: Options<GetPayoutHistoryData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPayoutHistoryResponses, GetPayoutHistoryErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/payouts',
        ...options
    });
};

/**
 * Withdraw payout balance to PayPal or Venmo
 *
 * Warning: certain amounts get withheld for fees. Please do not call this API endpoint without first acknowledging the warnings on the corresponding frontend page.
 */
export const withdrawPayout = <ThrowOnError extends boolean = false>(options: Options<WithdrawPayoutData, ThrowOnError>) => {
    return (options.client ?? client).post<WithdrawPayoutResponses, WithdrawPayoutErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/payouts',
        ...options
    });
};

/**
 * Get user's notifications
 */
export const getUserNotifications = <ThrowOnError extends boolean = false>(options: Options<GetUserNotificationsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUserNotificationsResponses, GetUserNotificationsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/user/{id|username}/notifications',
        ...options
    });
};

/**
 * Delete notification
 */
export const deleteNotification = <ThrowOnError extends boolean = false>(options: Options<DeleteNotificationData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteNotificationResponses, DeleteNotificationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notification/{id}',
        ...options
    });
};

/**
 * Get notification from ID
 */
export const getNotification = <ThrowOnError extends boolean = false>(options: Options<GetNotificationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetNotificationResponses, GetNotificationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notification/{id}',
        ...options
    });
};

/**
 * Mark notification as read
 */
export const readNotification = <ThrowOnError extends boolean = false>(options: Options<ReadNotificationData, ThrowOnError>) => {
    return (options.client ?? client).patch<ReadNotificationResponses, ReadNotificationErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notification/{id}',
        ...options
    });
};

/**
 * Delete multiple notifications
 */
export const deleteNotifications = <ThrowOnError extends boolean = false>(options: Options<DeleteNotificationsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteNotificationsResponses, DeleteNotificationsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notifications',
        ...options
    });
};

/**
 * Get multiple notifications
 */
export const getNotifications = <ThrowOnError extends boolean = false>(options: Options<GetNotificationsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetNotificationsResponses, GetNotificationsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notifications',
        ...options
    });
};

/**
 * Mark multiple notifications as read
 */
export const readNotifications = <ThrowOnError extends boolean = false>(options: Options<ReadNotificationsData, ThrowOnError>) => {
    return (options.client ?? client).patch<ReadNotificationsResponses, ReadNotificationsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/notifications',
        ...options
    });
};

/**
 * Get your open reports
 */
export const getOpenReports = <ThrowOnError extends boolean = false>(options?: Options<GetOpenReportsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetOpenReportsResponses, GetOpenReportsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/report',
        ...options
    });
};

/**
 * Report a project, user, or version
 *
 * Bring a project, user, or version to the attention of the moderators by reporting it.
 */
export const submitReport = <ThrowOnError extends boolean = false>(options?: Options<SubmitReportData, ThrowOnError>) => {
    return (options?.client ?? client).post<SubmitReportResponses, SubmitReportErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/report',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get report from ID
 */
export const getReport = <ThrowOnError extends boolean = false>(options: Options<GetReportData, ThrowOnError>) => {
    return (options.client ?? client).get<GetReportResponses, GetReportErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/report/{id}',
        ...options
    });
};

/**
 * Modify a report
 */
export const modifyReport = <ThrowOnError extends boolean = false>(options: Options<ModifyReportData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyReportResponses, ModifyReportErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/report/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get multiple reports
 */
export const getReports = <ThrowOnError extends boolean = false>(options: Options<GetReportsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetReportsResponses, GetReportsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/reports',
        ...options
    });
};

/**
 * Get a thread
 */
export const getThread = <ThrowOnError extends boolean = false>(options: Options<GetThreadData, ThrowOnError>) => {
    return (options.client ?? client).get<GetThreadResponses, GetThreadErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/thread/{id}',
        ...options
    });
};

/**
 * Send a text message to a thread
 */
export const sendThreadMessage = <ThrowOnError extends boolean = false>(options: Options<SendThreadMessageData, ThrowOnError>) => {
    return (options.client ?? client).post<SendThreadMessageResponses, SendThreadMessageErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/thread/{id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get multiple threads
 */
export const getThreads = <ThrowOnError extends boolean = false>(options: Options<GetThreadsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetThreadsResponses, GetThreadsErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/threads',
        ...options
    });
};

/**
 * Delete a thread message
 */
export const deleteThreadMessage = <ThrowOnError extends boolean = false>(options: Options<DeleteThreadMessageData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteThreadMessageResponses, DeleteThreadMessageErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/message/{id}',
        ...options
    });
};

/**
 * Get a project's team members
 */
export const getProjectTeamMembers = <ThrowOnError extends boolean = false>(options: Options<GetProjectTeamMembersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProjectTeamMembersResponses, GetProjectTeamMembersErrors, ThrowOnError>({
        url: '/project/{id|slug}/members',
        ...options
    });
};

/**
 * Get a team's members
 */
export const getTeamMembers = <ThrowOnError extends boolean = false>(options: Options<GetTeamMembersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetTeamMembersResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/members',
        ...options
    });
};

/**
 * Add a user to a team
 */
export const addTeamMember = <ThrowOnError extends boolean = false>(options: Options<AddTeamMemberData, ThrowOnError>) => {
    return (options.client ?? client).post<AddTeamMemberResponses, AddTeamMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/members',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get the members of multiple teams
 */
export const getTeams = <ThrowOnError extends boolean = false>(options: Options<GetTeamsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetTeamsResponses, unknown, ThrowOnError>({
        url: '/teams',
        ...options
    });
};

/**
 * Join a team
 */
export const joinTeam = <ThrowOnError extends boolean = false>(options: Options<JoinTeamData, ThrowOnError>) => {
    return (options.client ?? client).post<JoinTeamResponses, JoinTeamErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/join',
        ...options
    });
};

/**
 * Remove a member from a team
 */
export const deleteTeamMember = <ThrowOnError extends boolean = false>(options: Options<DeleteTeamMemberData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteTeamMemberResponses, DeleteTeamMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/members/{id|username}',
        ...options
    });
};

/**
 * Modify a team member's information
 */
export const modifyTeamMember = <ThrowOnError extends boolean = false>(options: Options<ModifyTeamMemberData, ThrowOnError>) => {
    return (options.client ?? client).patch<ModifyTeamMemberResponses, ModifyTeamMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/members/{id|username}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Transfer team's ownership to another user
 */
export const transferTeamOwnership = <ThrowOnError extends boolean = false>(options: Options<TransferTeamOwnershipData, ThrowOnError>) => {
    return (options.client ?? client).patch<TransferTeamOwnershipResponses, TransferTeamOwnershipErrors, ThrowOnError>({
        security: [
            {
                name: 'Authorization',
                type: 'apiKey'
            }
        ],
        url: '/team/{id}/owner',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get a list of categories
 *
 * Gets an array of categories, their icons, and applicable project types
 */
export const categoryList = <ThrowOnError extends boolean = false>(options?: Options<CategoryListData, ThrowOnError>) => {
    return (options?.client ?? client).get<CategoryListResponses, unknown, ThrowOnError>({
        url: '/tag/category',
        ...options
    });
};

/**
 * Get a list of loaders
 *
 * Gets an array of loaders, their icons, and supported project types
 */
export const loaderList = <ThrowOnError extends boolean = false>(options?: Options<LoaderListData, ThrowOnError>) => {
    return (options?.client ?? client).get<LoaderListResponses, unknown, ThrowOnError>({
        url: '/tag/loader',
        ...options
    });
};

/**
 * Get a list of game versions
 *
 * Gets an array of game versions and information about them
 */
export const versionList = <ThrowOnError extends boolean = false>(options?: Options<VersionListData, ThrowOnError>) => {
    return (options?.client ?? client).get<VersionListResponses, unknown, ThrowOnError>({
        url: '/tag/game_version',
        ...options
    });
};

/**
 * Get a list of licenses
 *
 * Deprecated - simply use SPDX IDs.
 *
 * @deprecated
 */
export const licenseList = <ThrowOnError extends boolean = false>(options?: Options<LicenseListData, ThrowOnError>) => {
    return (options?.client ?? client).get<LicenseListResponses, unknown, ThrowOnError>({
        url: '/tag/license',
        ...options
    });
};

/**
 * Get the text and title of a license
 */
export const licenseText = <ThrowOnError extends boolean = false>(options: Options<LicenseTextData, ThrowOnError>) => {
    return (options.client ?? client).get<LicenseTextResponses, LicenseTextErrors, ThrowOnError>({
        url: '/tag/license/{id}',
        ...options
    });
};

/**
 * Get a list of donation platforms
 *
 * Gets an array of donation platforms and information about them
 */
export const donationPlatformList = <ThrowOnError extends boolean = false>(options?: Options<DonationPlatformListData, ThrowOnError>) => {
    return (options?.client ?? client).get<DonationPlatformListResponses, unknown, ThrowOnError>({
        url: '/tag/donation_platform',
        ...options
    });
};

/**
 * Get a list of report types
 *
 * Gets an array of valid report types
 */
export const reportTypeList = <ThrowOnError extends boolean = false>(options?: Options<ReportTypeListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportTypeListResponses, unknown, ThrowOnError>({
        url: '/tag/report_type',
        ...options
    });
};

/**
 * Get a list of project types
 *
 * Gets an array of valid project types
 */
export const projectTypeList = <ThrowOnError extends boolean = false>(options?: Options<ProjectTypeListData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProjectTypeListResponses, unknown, ThrowOnError>({
        url: '/tag/project_type',
        ...options
    });
};

/**
 * Get a list of side types
 *
 * Gets an array of valid side types
 */
export const sideTypeList = <ThrowOnError extends boolean = false>(options?: Options<SideTypeListData, ThrowOnError>) => {
    return (options?.client ?? client).get<SideTypeListResponses, unknown, ThrowOnError>({
        url: '/tag/side_type',
        ...options
    });
};

/**
 * Forge Updates JSON file
 *
 * If you're a Forge mod developer, your Modrinth mods have an automatically generated `updates.json` using the
 * [Forge Update Checker](https://docs.minecraftforge.net/en/latest/misc/updatechecker/).
 *
 * The only setup is to insert the URL into the `[[mods]]` section of your `mods.toml` file as such:
 *
 * ```toml
 * [[mods]]
 * # the other stuff here - ID, version, display name, etc.
 * updateJSONURL = "https://api.modrinth.com/updates/{slug|ID}/forge_updates.json"
 * ```
 *
 * Replace `{slug|id}` with the slug or ID of your project.
 *
 * Modrinth will handle the rest! When you update your mod, Forge will notify your users that their copy of your mod is out of date.
 *
 * Make sure that the version format you use for your Modrinth releases is the same as the version format you use in your `mods.toml`.
 * If you use a format such as `1.2.3-forge` or `1.2.3+1.19` with your Modrinth releases but your `mods.toml` only has `1.2.3`,
 * the update checker may not function properly.
 *
 * If you're using NeoForge, NeoForge versions will, by default, not appear in the default URL.
 * You will need to add `?neoforge=only` to show your NeoForge-only versions, or `?neoforge=include` for both.
 *
 * ```toml
 * [[mods]]
 * # the other stuff here - ID, version, display name, etc.
 * updateJSONURL = "https://api.modrinth.com/updates/{slug|ID}/forge_updates.json?neoforge=only"
 * ```
 *
 */
export const forgeUpdates = <ThrowOnError extends boolean = false>(options: Options<ForgeUpdatesData, ThrowOnError>) => {
    return (options.client ?? client).get<ForgeUpdatesResponses, ForgeUpdatesErrors, ThrowOnError>({
        url: '/updates/{id|slug}/forge_updates.json',
        ...options
    });
};

/**
 * Various statistics about this Modrinth instance
 */
export const statistics = <ThrowOnError extends boolean = false>(options?: Options<StatisticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<StatisticsResponses, unknown, ThrowOnError>({
        url: '/statistics',
        ...options
    });
};
